<html><head><title>stompclt</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.29,
  using Pod::Simple::PullParser v3.29,
  under Perl v5.018004 at Mon Dec 14 07:40:02 2015 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>stompclt - versatile STOMP client</p>

<h1><a class='u'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p><b>stompclt</b> [<i>OPTIONS</i>]</p>

<h1><a class='u'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><b>stompclt</b> is a versatile tool to interact with messaging brokers speaking STOMP and/or message queues (see <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage%3A%3AQueue" class="podlinkpod"
>Messaging::Message::Queue</a>) on disk.</p>

<p>It receives messages (see <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage" class="podlinkpod"
>Messaging::Message</a>) from an incoming module,
optionally massaging them (i.e.
filtering and/or modifying),
and sends them to an outgoing module.
Depending on which modules are used,
the tool can perform different operations.</p>

<p>Here are the supported incoming modules:</p>

<ul>
<li>broker: connect to a messaging broker using STOMP,
subscribe to one or more destinations and receive the messages sent by the broker</li>

<li>queue: read messages from a message queue on disk</li>
</ul>

<p>Here are the supported outgoing modules:</p>

<ul>
<li>broker: connect to a messaging broker using STOMP and send the messages</li>

<li>queue: store the messages in a message queue on disk</li>
</ul>

<p>Here are some frequently used combinations:</p>

<ul>
<li><i>incoming broker + outgoing queue</i>: drain some destinations,
storing the messages on disk</li>

<li><i>incoming queue + outgoing broker</i>: (re-)send messages that have been previously stored on disk,
optionally with modifications (such as altering the destination)</li>

<li><i>incoming broker + outgoing broker</i>: shovel messages from one broker to another</li>
</ul>

<p>See the <a href="#EXAMPLES" class="podlinkpod"
>&#34;EXAMPLES&#34;</a> sections for concrete examples.</p>

<h1><a class='u'
name="OPTIONS"
>OPTIONS</a></h1>

<dl>
<dt><a name="--callback-code_CODE"
><b>--callback-code</b> <i>CODE</i></a></dt>

<dd>
<p>execute the given Perl code on each message,
see the <a href="#CALLBACK" class="podlinkpod"
>&#34;CALLBACK&#34;</a> section below for more information</p>

<dt><a name="--callback-data_KEY=VALUE..."
><b>--callback-data</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>pass this data to the user supplied callback code,
see the <a href="#CALLBACK" class="podlinkpod"
>&#34;CALLBACK&#34;</a> section below for more information</p>

<dt><a name="--callback-path_PATH"
><b>--callback-path</b> <i>PATH</i></a></dt>

<dd>
<p>execute the Perl code in the given file on each message,
see the <a href="#CALLBACK" class="podlinkpod"
>&#34;CALLBACK&#34;</a> section below for more information</p>

<dt><a name="--config,_--conf_PATH"
><b>--config</b>,
<b>--conf</b> <i>PATH</i></a></dt>

<dd>
<p>use the given configuration file,
see the <a href="#CONFIGURATION_FILE" class="podlinkpod"
>&#34;CONFIGURATION FILE&#34;</a> section below for more information</p>

<dt><a name="--count,_-c_INTEGER"
><b>--count</b>,
<b>-c</b> <i>INTEGER</i></a></dt>

<dd>
<p>process at most the given number of messages; note: when using an incoming broker,
to avoid consuming more messages,
it is recommended to enable the <b>--reliable</b> option</p>

<dt><a name="--daemon_|_--no-daemon"
><b>--daemon</b> | <b>--no-daemon</b></a></dt>

<dd>
<p>detach <b>stompclt</b> so that it becomes a daemon running in the background; debug,
warning and error messages will get sent to syslog; this option can be negated</p>

<dt><a name="--debug,_-d"
><b>--debug</b>,
<b>-d</b></a></dt>

<dd>
<p>show debugging information</p>

<dt><a name="--duration_SECONDS"
><b>--duration</b> <i>SECONDS</i></a></dt>

<dd>
<p>process messages during at most the given number of seconds and then stop; can be fractional</p>

<dt><a name="--heart-beat_|_--no-heart-beat"
><b>--heart-beat</b> | <b>--no-heart-beat</b></a></dt>

<dd>
<p>enable STOMP 1.1 heart-beats between <b>stompclt</b> and the broker(s); this option can be negated</p>

<dt><a name="--help,_-h,_-?"
><b>--help</b>,
<b>-h</b>,
<b>-?</b></a></dt>

<dd>
<p>show some help</p>

<dt><a name="--incoming-broker-auth_STRING"
><b>--incoming-broker-auth</b> <i>STRING</i></a></dt>

<dd>
<p>use this authentication string (see <a href="http://search.cpan.org/perldoc?Authen%3A%3ACredential" class="podlinkpod"
>Authen::Credential</a>) to authenticate to the incoming broker; this option can be given multiple times</p>

<dt><a name="--incoming-broker-connect_KEY=VALUE..."
><b>--incoming-broker-connect</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>use these options in the STOMP CONNECT frame sent to the incoming broker</p>

<dt><a name="--incoming-broker-sockopts_KEY=VALUE..."
><b>--incoming-broker-sockopts</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>use these socket options when connecting to the incoming broker</p>

<dt><a name="--incoming-broker-stomp-debug_STRING"
><b>--incoming-broker-stomp-debug</b> <i>STRING</i></a></dt>

<dd>
<p>set the STOMP debug flags (see <a href="http://search.cpan.org/perldoc?Net%3A%3ASTOMP%3A%3AClient" class="podlinkpod"
>Net::STOMP::Client</a>) when interacting with the incoming broker</p>

<dt><a name="--incoming-broker-type_STRING"
><b>--incoming-broker-type</b> <i>STRING</i></a></dt>

<dd>
<p>set the incoming broker type; this can be useful when using STOMP features which are broker specific</p>

<dt><a name="--incoming-broker-uri_URI"
><b>--incoming-broker-uri</b> <i>URI</i></a></dt>

<dd>
<p>use this connection URI (see <a href="http://search.cpan.org/perldoc?Net%3A%3ASTOMP%3A%3AClient" class="podlinkpod"
>Net::STOMP::Client</a>) to connect to the incoming broker</p>

<dt><a name="--incoming-queue_KEY=VALUE..."
><b>--incoming-queue</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>read incoming messages from the given message queue (see <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage%3A%3AQueue" class="podlinkpod"
>Messaging::Message::Queue</a>)</p>

<dt><a name="--lazy_|_--no-lazy"
><b>--lazy</b> | <b>--no-lazy</b></a></dt>

<dd>
<p>initialize the outgoing module only after having received the first message; this option can be negated</p>

<dt><a name="--list,_-l"
><b>--list</b>,
<b>-l</b></a></dt>

<dd>
<p>show all supported options</p>

<dt><a name="--loop_|_--no-loop"
><b>--loop</b> | <b>--no-loop</b></a></dt>

<dd>
<p>when using an incoming message queue,
loop over it; this option can be negated</p>

<dt><a name="--manual,_-m"
><b>--manual</b>,
<b>-m</b></a></dt>

<dd>
<p>show this manual</p>

<dt><a name="--outgoing-broker-auth_STRING"
><b>--outgoing-broker-auth</b> <i>STRING</i></a></dt>

<dd>
<p>use this authentication string (see <a href="http://search.cpan.org/perldoc?Authen%3A%3ACredential" class="podlinkpod"
>Authen::Credential</a>) to authenticate to the outgoing broker; this option can be given multiple times</p>

<dt><a name="--outgoing-broker-connect_KEY=VALUE..."
><b>--outgoing-broker-connect</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>use these options in the STOMP CONNECT frame sent to the outgoing broker</p>

<dt><a name="--outgoing-broker-sockopts_KEY=VALUE..."
><b>--outgoing-broker-sockopts</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>use these socket options when connecting to the outgoing broker</p>

<dt><a name="--outgoing-broker-stomp-debug_STRING"
><b>--outgoing-broker-stomp-debug</b> <i>STRING</i></a></dt>

<dd>
<p>set the STOMP debug flags (see <a href="http://search.cpan.org/perldoc?Net%3A%3ASTOMP%3A%3AClient" class="podlinkpod"
>Net::STOMP::Client</a>) when interacting with the outgoing broker</p>

<dt><a name="--outgoing-broker-type_STRING"
><b>--outgoing-broker-type</b> <i>STRING</i></a></dt>

<dd>
<p>set the outgoing broker type; this can be useful when using STOMP features which are broker specific</p>

<dt><a name="--outgoing-broker-uri_URI"
><b>--outgoing-broker-uri</b> <i>URI</i></a></dt>

<dd>
<p>use this connection URI (see <a href="http://search.cpan.org/perldoc?Net%3A%3ASTOMP%3A%3AClient" class="podlinkpod"
>Net::STOMP::Client</a>) to connect to the outgoing broker</p>

<dt><a name="--outgoing-queue_KEY=VALUE..."
><b>--outgoing-queue</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>store outgoing messages into the given message queue (see <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage%3A%3AQueue" class="podlinkpod"
>Messaging::Message::Queue</a>)</p>

<dt><a name="--pidfile_PATH"
><b>--pidfile</b> <i>PATH</i></a></dt>

<dd>
<p>use this pid file</p>

<dt><a name="--prefetch_INTEGER"
><b>--prefetch</b> <i>INTEGER</i></a></dt>

<dd>
<p>set the prefetch value (i.e.
the maximum number of messages to received without acknowledging them) on the incoming broker</p>

<dt><a name="--quit"
><b>--quit</b></a></dt>

<dd>
<p>tell another instance of <b>stompclt</b> (identified by its pid file,
as specified by the <b>--pidfile</b> option) to quit</p>

<dt><a name="--reliable_|_--no-reliable"
><b>--reliable</b> | <b>--no-reliable</b></a></dt>

<dd>
<p>use STOMP features for more reliable messaging (i.e.
client side acknowledgments and receipts) at the cost of less performance; this option can be negated</p>

<dt><a name="--remove_|_--no-remove"
><b>--remove</b> | <b>--no-remove</b></a></dt>

<dd>
<p>when using an incoming message queue,
remove the processed messages; this option can be negated</p>

<dt><a name="--statistics,_-s_|_--no-statistics"
><b>--statistics</b>,
<b>-s</b> | <b>--no-statistics</b></a></dt>

<dd>
<p>report statistics at the end of the execution; this option can be negated</p>

<dt><a name="--status"
><b>--status</b></a></dt>

<dd>
<p>get the status of another instance of <b>stompclt</b> (identified by its pid file,
as specified by the <b>--pidfile</b> option); the exit code will be zero if the instance is alive and non-zero otherwise</p>

<dt><a name="--subscribe_KEY=VALUE..."
><b>--subscribe</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>use these options in the STOMP SUBSCRIBE frame used with the incoming broker; this option can be given multiple times</p>

<dt><a name="--timeout-broker_SECONDS"
><b>--timeout-broker</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout when interacting with the broker (e.g.
getting receipts back); can be fractional</p>

<dt><a name="--timeout-client_SECONDS"
><b>--timeout-client</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout for the client heart-beat; can be fractional (default: 40)</p>

<dt><a name="--timeout-connect_SECONDS"
><b>--timeout-connect</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout when connecting to the broker; can be fractional</p>

<dt><a name="--timeout-disconnect_SECONDS"
><b>--timeout-disconnect</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout when disconnecting from the broker; can be fractional (default: 60)</p>

<dt><a name="--timeout-flush_SECONDS"
><b>--timeout-flush</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout when attempting to send the last bytes to the broker just before disconnecting; can be fractional (default: 60)</p>

<dt><a name="--timeout-inactivity_SECONDS"
><b>--timeout-inactivity</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout in the incoming module to stop <b>stompclt</b> when no new messages have been received (aka drain mode); can be fractional</p>

<dt><a name="--timeout-linger_SECONDS"
><b>--timeout-linger</b> <i>SECONDS</i></a></dt>

<dd>
<p>when stopping <b>stompclt</b>,
use this timeout to finish interacting with the broker; can be fractional</p>

<dt><a name="--timeout-server_SECONDS"
><b>--timeout-server</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout for the server heart-beat; can be fractional (default: 10)</p>

<dt><a name="--timeout-status_SECONDS"
><b>--timeout-status</b> <i>SECONDS</i></a></dt>

<dd>
<p>use this timeout when checking the status with <b>--status</b>; can be fractional</p>

<dt><a name="--unsubscribe_KEY=VALUE..."
><b>--unsubscribe</b> <i>KEY=VALUE...</i></a></dt>

<dd>
<p>use these options in the STOMP UNSUBSCRIBE frame used with the incoming broker; this option can be given multiple times and should match the <b>--subscribe</b> options</p>

<dt><a name="--version"
><b>--version</b></a></dt>

<dd>
<p>display version information</p>

<dt><a name="--window_INTEGER"
><b>--window</b> <i>INTEGER</i></a></dt>

<dd>
<p>keep at most the given number of not-yet-acknowledged messages in memory</p>
</dd>
</dl>

<p>To list all the available options in a compact form,
type:</p>

<pre>  $ stompclt -l</pre>

<h1><a class='u'
name="CONFIGURATION_FILE"
>CONFIGURATION FILE</a></h1>

<p><b>stompclt</b> can read its options from a configuration file. For this, the <a href="http://search.cpan.org/perldoc?Config%3A%3AGeneral" class="podlinkpod"
>Config::General</a> module is used and the option names are the same as on the command line. For instance:</p>

<pre>  daemon = true
  pidfile = /var/run/stompclt.pid
  incoming-queue = path=/var/spool/stompclt
  outgoing-broker-uri = stomp://broker.acme.com:6163
  outgoing-broker-auth = &#34;plain name=guest pass=guest&#34;</pre>

<p>Alternatively, options can be nested:</p>

<pre>  &#60;outgoing-broker&#62;
      uri = stomp://broker.acme.com:6163
      auth = &#34;plain name=guest pass=guest&#34;
  &#60;/outgoing-broker&#62;</pre>

<p>Or even:</p>

<pre>  &#60;outgoing&#62;
      &#60;broker&#62;
          uri = stomp://broker.acme.com:6163
          &#60;auth&#62;
              scheme = plain
              name = guest
              pass = guest
          &#60;/auth&#62;
      &#60;/broker&#62;
  &#60;/outgoing&#62;</pre>

<p>The options specified on the command line have precedence over the ones found in the configuration file.</p>

<h1><a class='u'
name="CALLBACK"
>CALLBACK</a></h1>

<p><b>stompclt</b> can be given Perl code to execute on all processed messages. This can be used for different purposes:</p>

<ul>
<li>massaging: the code can change any part of the message, including setting or removing header fields</li>

<li>filtering: the code can decide if the message must be given to the outgoing module or not</li>

<li>displaying: the code can print any part of the message</li>

<li>copying: the code can store a copy of the message into files or message queues</li>
</ul>

<p>To use callbacks, the <b>--callback-path</b> or <b>--callback-code</b> option must be used. The Perl code must provide functions with the following signature:</p>

<dl>
<dt><a name="start(DATA)"
>start(DATA)</a></dt>

<dd>
<p>(optional) this will be called when the program starts, with the supplied data (see the <b>--callback-data</b> option) as a hash reference</p>

<dt><a name="check(MESSAGE)"
>check(MESSAGE)</a></dt>

<dd>
<p>(mandatory) this will be called when the program has one message to process; it will be given the message (see <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage" class="podlinkpod"
>Messaging::Message</a>) and must return either a message (it could be the same one or a new one) or a string describing why the message has been dropped</p>

<dt><a name="idle()"
>idle()</a></dt>

<dd>
<p>(optional) this will be called when the program has no message to process</p>

<dt><a name="stop()"
>stop()</a></dt>

<dd>
<p>(optional) this will be called when the program stops</p>
</dd>
</dl>

<p>The code can be put in a file, on the command line or in the <b>stompclt</b> configuration file, using the &#34;here document&#34; syntax.</p>

<p>Here is an example (to be put in the <b>stompclt</b> configuration file) that prints on stdout a JSON array of messages:</p>

<pre>  callback-code = &#60;&#60;EOF
      my($count);
      sub start ($) {
          $count = 0;
      }
      sub check ($) {
          my($msg) = @_;
          print($count++ ? &#34;,&#34; : &#34;[&#34;);
          print($msg-&#62;serialize(), &#34;\n&#34;);
          return($msg);
      }
      sub stop () {
          print($count ? &#34;]\n&#34; : &#34;[]\n&#34;);
      }
  EOF</pre>

<p>For simple callback code that only needs the <code>check</code> subroutine, it is enough to supply the &#34;inside code&#34;. If the subroutine definition is missing, the supplied code will be wrapped with:</p>

<pre>  sub check ($) {
      my($msg) = @_;
      local *hdr = $msg-&#62;header();
      local *bdy = $msg-&#62;body_ref();
      ... your code goes here ...
      return($msg);
  }</pre>

<p>This allows for instance to remove the <code>message-id</code> header with something like:</p>

<pre>  $ stompclt ... --callback-code &#39;delete($hdr{&#34;message-id&#34;})&#39;</pre>

<p>Or to filter on message bodies with:</p>

<pre>  $ stompclt ... --callback-code &#39;return(&#34;skip&#34;) unless $bdy =~ /error/&#39;</pre>

<h1><a class='u'
name="SUBSCRIPTIONS"
>SUBSCRIPTIONS</a></h1>

<p>In the case of an incoming broker, <b>stompclt</b> deals with the subscriptions defined by the <b>--subscribe</b> option.</p>

<p>Regardless of the <b>--reliable</b> option, subscriptions are always made using receipts. Also, if missing, an <code>id</code> header is always added.</p>

<p>Here is for instance how to create a named durable topic subscription using Apollo:</p>

<pre>  $ stompclt ... --subscribe &#39;destination=/topic/foo persistent=true id=mysub&#39;</pre>

<p>By default, when it finishes, <b>stompclt</b> does not unsubscribe. It simply disconnects from the broker and the latter will perform the necessary cleanup when terminating the STOMP connection.</p>

<p>If the <b>--unsubscribe</b> option is given, even if it is empty, <b>stompclt</b> will explicitly unsubscribe before disconnecting, also using receipts.</p>

<p>Here is for instance how to destroy, when <b>stompclt</b> ends, the durable topic subscription created above:</p>

<pre>  $ stompclt ... --unsubscribe &#39;persistent=true&#39;</pre>

<p>There is no need to give the subscription <code>id</code> in the <b>--unsubscribe</b> option because, by default, it comes from the matching <b>--subscribe</b> option.</p>

<h1><a class='u'
name="UDP_SUPPORT"
>UDP SUPPORT</a></h1>

<p><b>stompclt</b> has experimental UDP support (outgoing only). This has been tested with Apollo.</p>

<p>To use it, simply specify an outgoing URI that uses UDP such as:</p>

<pre>  $ stompclt ... --outgoing-broker-uri udp://broker.acme.com:6163</pre>

<p>Features such as authentication, heart beating, reliability and socket options are not supported over UDP.</p>

<h1><a class='u'
name="EXAMPLES"
>EXAMPLES</a></h1>

<h2><a class='u'
name="SENDING"
>SENDING</a></h2>

<p>Here is an example of a configuration file for a message sender daemon (from queue to broker), forcing the <code>persistent</code> header to <code>true</code> (something which is highly recommended for reliable messaging) and setting the destination:</p>

<pre>  # define the source message queue
  &#60;incoming-queue&#62;
      path = /var/spool/sender
  &#60;/incoming-queue&#62;
  # modify the message header on the fly
  callback-code = &#60;&#60;EOF
      $hdr{destination} = &#34;/queue/app1.data&#34;;
      $hdr{persistent} = &#34;true&#34;;
  EOF
  # define the destination broker
  &#60;outgoing-broker&#62;
      uri = &#34;stomp://broker.acme.com:6163&#34;
  &#60;/outgoing-broker&#62;
  # miscellaneous options
  reliable = true
  pidfile = /var/run/sender.pid
  daemon = true
  loop = true
  remove = true</pre>

<h2><a class='u'
name="RECEIVING"
>RECEIVING</a></h2>

<p>Here is an example of a configuration file for a message receiver daemon (from broker to queue):</p>

<pre>  # define the source broker
  &#60;incoming-broker&#62;
      uri = &#34;stomp://broker.acme.com:6163&#34;
      &#60;auth&#62;
          scheme = plain
          name = receiver
          pass = secret
      &#60;/auth&#62;
  &#60;/incoming-broker&#62;
  # define the subscriptions
  &#60;subscribe&#62;
      destination = /queue/app1.data
  &#60;/subscribe&#62;
  &#60;subscribe&#62;
      destination = /queue/app2.data
  &#60;/subscribe&#62;
  # define the destination message queue
  &#60;outgoing-queue&#62;
      path = /var/spool/receiver
  &#60;/outgoing-queue&#62;
  # miscellaneous options
  pidfile = /var/run/receiver.pid
  daemon = true</pre>

<p>Here is how to use the configuration file above with some options overridden on the command line to drain the queues in the foreground:</p>

<pre>  $ stompclt --config test.conf --no-daemon --timeout-inactivity 10</pre>

<h2><a class='u'
name="SHOVELING"
>SHOVELING</a></h2>

<p>Here is an example of a configuration file for a message shoveler (from broker to broker), clearing some headers on the fly so that messages can be replayed safely:</p>

<pre>  # define the source broker
  &#60;incoming-broker&#62;
      uri = &#34;stomp://broker.acme.com:6163&#34;
  &#60;/incoming-broker&#62;
  # define the subscriptions
  &#60;subscribe&#62;
      destination = /queue/app1.data
  &#60;/subscribe&#62;
  &#60;subscribe&#62;
      destination = /queue/app2.data
  &#60;/subscribe&#62;
  # define the destination broker
  &#60;outgoing-broker&#62;
      uri = &#34;stomp://dev-broker.acme.com:6163&#34;
  &#60;/outgoing-broker&#62;
  # modify the message so that it can be replayed
  callback-code = &#60;&#60;EOF
      foreach my $name (qw(message-id timestamp expires)) {
          delete($hdr{$name});
      }
  EOF</pre>

<h2><a class='u'
name="TAPPING"
>TAPPING</a></h2>

<p>Callback code can also be used to tap messages, i.e. get a copy of all messages processed by <b>stompclt</b>. Here is some callback code for this purpose that could for instance be merged with the shoveling code above. It also shows how to use the <b>--callback-data</b> option:</p>

<pre>  callback-code = &#60;&#60;EOF
      my($queue);
      sub start ($) {
          my($data) = @_;
          $queue = Messaging::Message::Queue-&#62;new($data);
      }
      sub check ($) {
          my($msg) = @_;
          $queue-&#62;add_message($msg);
          return($msg);
      }
  EOF</pre>

<p>Callback data must be given to specify which message queue to use:</p>

<pre>  $ stompclt --config tap.conf --callback-data &#34;path=/tmp/tap type=DQS&#34;</pre>

<h1><a class='u'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="http://search.cpan.org/perldoc?Authen%3A%3ACredential" class="podlinkpod"
>Authen::Credential</a>, <a href="http://search.cpan.org/perldoc?Config%3A%3AGeneral" class="podlinkpod"
>Config::General</a>, <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage" class="podlinkpod"
>Messaging::Message</a>, <a href="http://search.cpan.org/perldoc?Messaging%3A%3AMessage%3A%3AQueue" class="podlinkpod"
>Messaging::Message::Queue</a>, <a href="http://search.cpan.org/perldoc?Net%3A%3ASTOMP%3A%3AClient" class="podlinkpod"
>Net::STOMP::Client</a>.</p>

<h1><a class='u'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Lionel Cons <a href="http://cern.ch/lionel.cons" class="podlinkurl"
>http://cern.ch/lionel.cons</a></p>

<p>Copyright (C) CERN 2012-2015</p>

<!-- end doc -->

</body></html>
